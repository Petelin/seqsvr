// Code generated by protoc-gen-go. DO NOT EDIT.
// source: store_server.proto

package storesvr

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NoContent struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoContent) Reset()         { *m = NoContent{} }
func (m *NoContent) String() string { return proto.CompactTextString(m) }
func (*NoContent) ProtoMessage()    {}
func (*NoContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{0}
}

func (m *NoContent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoContent.Unmarshal(m, b)
}
func (m *NoContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoContent.Marshal(b, m, deterministic)
}
func (m *NoContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoContent.Merge(m, src)
}
func (m *NoContent) XXX_Size() int {
	return xxx_messageInfo_NoContent.Size(m)
}
func (m *NoContent) XXX_DiscardUnknown() {
	xxx_messageInfo_NoContent.DiscardUnknown(m)
}

var xxx_messageInfo_NoContent proto.InternalMessageInfo

type UpdateMaxSeqReq struct {
	SectionId            uint64   `protobuf:"varint,1,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	MaxSeq               uint64   `protobuf:"varint,2,opt,name=max_seq,json=maxSeq,proto3" json:"max_seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateMaxSeqReq) Reset()         { *m = UpdateMaxSeqReq{} }
func (m *UpdateMaxSeqReq) String() string { return proto.CompactTextString(m) }
func (*UpdateMaxSeqReq) ProtoMessage()    {}
func (*UpdateMaxSeqReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{1}
}

func (m *UpdateMaxSeqReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateMaxSeqReq.Unmarshal(m, b)
}
func (m *UpdateMaxSeqReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateMaxSeqReq.Marshal(b, m, deterministic)
}
func (m *UpdateMaxSeqReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMaxSeqReq.Merge(m, src)
}
func (m *UpdateMaxSeqReq) XXX_Size() int {
	return xxx_messageInfo_UpdateMaxSeqReq.Size(m)
}
func (m *UpdateMaxSeqReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMaxSeqReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMaxSeqReq proto.InternalMessageInfo

func (m *UpdateMaxSeqReq) GetSectionId() uint64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *UpdateMaxSeqReq) GetMaxSeq() uint64 {
	if m != nil {
		return m.MaxSeq
	}
	return 0
}

type GetSeqMaxReq struct {
	SectionId            uint64   `protobuf:"varint,1,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSeqMaxReq) Reset()         { *m = GetSeqMaxReq{} }
func (m *GetSeqMaxReq) String() string { return proto.CompactTextString(m) }
func (*GetSeqMaxReq) ProtoMessage()    {}
func (*GetSeqMaxReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{2}
}

func (m *GetSeqMaxReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetSeqMaxReq.Unmarshal(m, b)
}
func (m *GetSeqMaxReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetSeqMaxReq.Marshal(b, m, deterministic)
}
func (m *GetSeqMaxReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSeqMaxReq.Merge(m, src)
}
func (m *GetSeqMaxReq) XXX_Size() int {
	return xxx_messageInfo_GetSeqMaxReq.Size(m)
}
func (m *GetSeqMaxReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSeqMaxReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSeqMaxReq proto.InternalMessageInfo

func (m *GetSeqMaxReq) GetSectionId() uint64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

type GetSeqMaxResp struct {
	MaxSeq               uint64   `protobuf:"varint,1,opt,name=max_seq,json=maxSeq,proto3" json:"max_seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSeqMaxResp) Reset()         { *m = GetSeqMaxResp{} }
func (m *GetSeqMaxResp) String() string { return proto.CompactTextString(m) }
func (*GetSeqMaxResp) ProtoMessage()    {}
func (*GetSeqMaxResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{3}
}

func (m *GetSeqMaxResp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetSeqMaxResp.Unmarshal(m, b)
}
func (m *GetSeqMaxResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetSeqMaxResp.Marshal(b, m, deterministic)
}
func (m *GetSeqMaxResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSeqMaxResp.Merge(m, src)
}
func (m *GetSeqMaxResp) XXX_Size() int {
	return xxx_messageInfo_GetSeqMaxResp.Size(m)
}
func (m *GetSeqMaxResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSeqMaxResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSeqMaxResp proto.InternalMessageInfo

func (m *GetSeqMaxResp) GetMaxSeq() uint64 {
	if m != nil {
		return m.MaxSeq
	}
	return 0
}

type GetMapRouterReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMapRouterReq) Reset()         { *m = GetMapRouterReq{} }
func (m *GetMapRouterReq) String() string { return proto.CompactTextString(m) }
func (*GetMapRouterReq) ProtoMessage()    {}
func (*GetMapRouterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{4}
}

func (m *GetMapRouterReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetMapRouterReq.Unmarshal(m, b)
}
func (m *GetMapRouterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetMapRouterReq.Marshal(b, m, deterministic)
}
func (m *GetMapRouterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapRouterReq.Merge(m, src)
}
func (m *GetMapRouterReq) XXX_Size() int {
	return xxx_messageInfo_GetMapRouterReq.Size(m)
}
func (m *GetMapRouterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapRouterReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapRouterReq proto.InternalMessageInfo

type Sections struct {
	SectionIds           []uint64 `protobuf:"varint,1,rep,packed,name=section_ids,json=sectionIds,proto3" json:"section_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sections) Reset()         { *m = Sections{} }
func (m *Sections) String() string { return proto.CompactTextString(m) }
func (*Sections) ProtoMessage()    {}
func (*Sections) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{5}
}

func (m *Sections) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Sections.Unmarshal(m, b)
}
func (m *Sections) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Sections.Marshal(b, m, deterministic)
}
func (m *Sections) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sections.Merge(m, src)
}
func (m *Sections) XXX_Size() int {
	return xxx_messageInfo_Sections.Size(m)
}
func (m *Sections) XXX_DiscardUnknown() {
	xxx_messageInfo_Sections.DiscardUnknown(m)
}

var xxx_messageInfo_Sections proto.InternalMessageInfo

func (m *Sections) GetSectionIds() []uint64 {
	if m != nil {
		return m.SectionIds
	}
	return nil
}

type GetMapRouterResp struct {
	Version              uint64               `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	RouterMap            map[string]*Sections `protobuf:"bytes,2,rep,name=router_map,json=routerMap,proto3" json:"router_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetMapRouterResp) Reset()         { *m = GetMapRouterResp{} }
func (m *GetMapRouterResp) String() string { return proto.CompactTextString(m) }
func (*GetMapRouterResp) ProtoMessage()    {}
func (*GetMapRouterResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{6}
}

func (m *GetMapRouterResp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetMapRouterResp.Unmarshal(m, b)
}
func (m *GetMapRouterResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetMapRouterResp.Marshal(b, m, deterministic)
}
func (m *GetMapRouterResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapRouterResp.Merge(m, src)
}
func (m *GetMapRouterResp) XXX_Size() int {
	return xxx_messageInfo_GetMapRouterResp.Size(m)
}
func (m *GetMapRouterResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapRouterResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapRouterResp proto.InternalMessageInfo

func (m *GetMapRouterResp) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetMapRouterResp) GetRouterMap() map[string]*Sections {
	if m != nil {
		return m.RouterMap
	}
	return nil
}

type SetHostRouterReq struct {
	HostName             string    `protobuf:"bytes,1,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	Sections             *Sections `protobuf:"bytes,2,opt,name=sections,proto3" json:"sections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SetHostRouterReq) Reset()         { *m = SetHostRouterReq{} }
func (m *SetHostRouterReq) String() string { return proto.CompactTextString(m) }
func (*SetHostRouterReq) ProtoMessage()    {}
func (*SetHostRouterReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_08ed7522737fbf33, []int{7}
}

func (m *SetHostRouterReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetHostRouterReq.Unmarshal(m, b)
}
func (m *SetHostRouterReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetHostRouterReq.Marshal(b, m, deterministic)
}
func (m *SetHostRouterReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetHostRouterReq.Merge(m, src)
}
func (m *SetHostRouterReq) XXX_Size() int {
	return xxx_messageInfo_SetHostRouterReq.Size(m)
}
func (m *SetHostRouterReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetHostRouterReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetHostRouterReq proto.InternalMessageInfo

func (m *SetHostRouterReq) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *SetHostRouterReq) GetSections() *Sections {
	if m != nil {
		return m.Sections
	}
	return nil
}

func init() {
	proto.RegisterType((*NoContent)(nil), "storesvr.no_content")
	proto.RegisterType((*UpdateMaxSeqReq)(nil), "storesvr.UpdateMaxSeqReq")
	proto.RegisterType((*GetSeqMaxReq)(nil), "storesvr.GetSeqMaxReq")
	proto.RegisterType((*GetSeqMaxResp)(nil), "storesvr.GetSeqMaxResp")
	proto.RegisterType((*GetMapRouterReq)(nil), "storesvr.GetMapRouterReq")
	proto.RegisterType((*Sections)(nil), "storesvr.Sections")
	proto.RegisterType((*GetMapRouterResp)(nil), "storesvr.GetMapRouterResp")
	proto.RegisterMapType((map[string]*Sections)(nil), "storesvr.GetMapRouterResp.RouterMapEntry")
	proto.RegisterType((*SetHostRouterReq)(nil), "storesvr.SetHostRouterReq")
}

func init() { proto.RegisterFile("store_server.proto", fileDescriptor_08ed7522737fbf33) }

var fileDescriptor_08ed7522737fbf33 = []byte{
	// 420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0xcf, 0x8e, 0xd3, 0x30,
	0x10, 0xc6, 0x9b, 0x76, 0xd9, 0x6d, 0xa6, 0x5d, 0xb6, 0x8c, 0x10, 0x1b, 0x82, 0x10, 0x95, 0x4f,
	0x41, 0x88, 0x1c, 0xca, 0x05, 0x71, 0x40, 0xe2, 0x80, 0xba, 0x3d, 0x14, 0x21, 0x47, 0x9c, 0x23,
	0xb3, 0x1d, 0x89, 0x0a, 0x12, 0x3b, 0xb6, 0x37, 0xea, 0xbe, 0x0f, 0x0f, 0xc3, 0x63, 0xa1, 0xba,
	0xf9, 0x5b, 0x41, 0xf7, 0x66, 0xcf, 0x8c, 0xbf, 0x2f, 0xf9, 0xf9, 0x33, 0xa0, 0xb1, 0x52, 0x53,
	0x6a, 0x48, 0x97, 0xa4, 0x63, 0xa5, 0xa5, 0x95, 0x38, 0x76, 0x35, 0x53, 0x6a, 0x36, 0x05, 0xc8,
	0x65, 0x7a, 0x2b, 0x73, 0x4b, 0xb9, 0x65, 0x2b, 0xb8, 0xfa, 0xa6, 0x36, 0xc2, 0xd2, 0x5a, 0xec,
	0x12, 0x2a, 0x38, 0x15, 0xf8, 0x12, 0xc0, 0xd0, 0xad, 0xdd, 0xca, 0x3c, 0xdd, 0x6e, 0x02, 0x6f,
	0xee, 0x45, 0x67, 0xdc, 0xaf, 0x2a, 0xab, 0x0d, 0x5e, 0xc3, 0x45, 0x26, 0x76, 0xa9, 0xa1, 0x22,
	0x18, 0xba, 0xde, 0x79, 0xe6, 0x8e, 0xb2, 0xb7, 0x30, 0x5d, 0x92, 0x4d, 0xa8, 0x58, 0x8b, 0xdd,
	0xc3, 0x3a, 0x2c, 0x82, 0xcb, 0xce, 0xb8, 0x51, 0x5d, 0x61, 0xaf, 0x27, 0xfc, 0x04, 0xae, 0x96,
	0x64, 0xd7, 0x42, 0x71, 0x79, 0x67, 0x49, 0x73, 0x2a, 0xd8, 0x1b, 0x18, 0x27, 0x07, 0x25, 0x83,
	0xaf, 0x60, 0xd2, 0xfa, 0x98, 0xc0, 0x9b, 0x8f, 0xa2, 0x33, 0x0e, 0x8d, 0x91, 0x61, 0x7f, 0x3c,
	0x98, 0xf5, 0x05, 0x8c, 0xc2, 0x00, 0x2e, 0x4a, 0xd2, 0x66, 0x2b, 0xf3, 0xca, 0xad, 0xde, 0xe2,
	0x0d, 0x80, 0x76, 0x73, 0x69, 0x26, 0x54, 0x30, 0x9c, 0x8f, 0xa2, 0xc9, 0xe2, 0x75, 0x5c, 0xf3,
	0x8b, 0x8f, 0x95, 0xe2, 0xc3, 0x72, 0x2d, 0xd4, 0xe7, 0xdc, 0xea, 0x7b, 0xee, 0xeb, 0x7a, 0x1f,
	0x7e, 0x85, 0xc7, 0xfd, 0x26, 0xce, 0x60, 0xf4, 0x93, 0xee, 0x9d, 0xa3, 0xcf, 0xf7, 0x4b, 0x8c,
	0xe0, 0x51, 0x29, 0x7e, 0xdd, 0x91, 0x83, 0x39, 0x59, 0x60, 0x6b, 0x54, 0xff, 0x20, 0x3f, 0x0c,
	0x7c, 0x18, 0xbe, 0xf7, 0x58, 0x0a, 0xb3, 0x84, 0xec, 0x8d, 0x34, 0xb6, 0x61, 0x81, 0x2f, 0xc0,
	0xff, 0x21, 0x8d, 0x4d, 0x73, 0x91, 0x51, 0xa5, 0x3c, 0xde, 0x17, 0xbe, 0x88, 0x8c, 0x30, 0x86,
	0x71, 0x45, 0xc2, 0x9c, 0x70, 0x68, 0x66, 0x16, 0xbf, 0x87, 0x30, 0x49, 0xf6, 0xfd, 0xc4, 0xa5,
	0x07, 0x3f, 0xc1, 0xb4, 0x9b, 0x0f, 0x7c, 0xde, 0x9e, 0x3e, 0xca, 0x4d, 0xf8, 0xb4, 0x6d, 0x75,
	0x02, 0x36, 0xc0, 0x8f, 0xe0, 0x37, 0x17, 0x8d, 0xcf, 0x7a, 0x20, 0x9b, 0xb0, 0x84, 0xd7, 0xff,
	0xac, 0x1b, 0xc5, 0x06, 0xb8, 0x74, 0xb9, 0x6a, 0x98, 0x77, 0x3f, 0xe1, 0x28, 0x16, 0x61, 0xf8,
	0xff, 0x6b, 0x62, 0x03, 0x5c, 0xc1, 0x65, 0x0f, 0x1e, 0x86, 0x5d, 0x14, 0x7d, 0xaa, 0xa7, 0xa5,
	0xbe, 0x9f, 0xbb, 0x57, 0xf5, 0xee, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7b, 0xba, 0x93, 0xf2,
	0x6b, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StoreServerClient is the client API for StoreServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreServerClient interface {
	// 更新MaxSeq
	UpdateMaxSeq(ctx context.Context, in *UpdateMaxSeqReq, opts ...grpc.CallOption) (*NoContent, error)
	// 获取MaxSeq
	GetSeqMax(ctx context.Context, in *GetSeqMaxReq, opts ...grpc.CallOption) (*GetSeqMaxResp, error)
	// 获取全路由表
	GetMapRouter(ctx context.Context, in *GetMapRouterReq, opts ...grpc.CallOption) (*GetMapRouterResp, error)
	// 设置host路由表
	SetHostRouter(ctx context.Context, in *SetHostRouterReq, opts ...grpc.CallOption) (*GetMapRouterResp, error)
}

type storeServerClient struct {
	cc *grpc.ClientConn
}

func NewStoreServerClient(cc *grpc.ClientConn) StoreServerClient {
	return &storeServerClient{cc}
}

func (c *storeServerClient) UpdateMaxSeq(ctx context.Context, in *UpdateMaxSeqReq, opts ...grpc.CallOption) (*NoContent, error) {
	out := new(NoContent)
	err := c.cc.Invoke(ctx, "/storesvr.StoreServer/UpdateMaxSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServerClient) GetSeqMax(ctx context.Context, in *GetSeqMaxReq, opts ...grpc.CallOption) (*GetSeqMaxResp, error) {
	out := new(GetSeqMaxResp)
	err := c.cc.Invoke(ctx, "/storesvr.StoreServer/GetSeqMax", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServerClient) GetMapRouter(ctx context.Context, in *GetMapRouterReq, opts ...grpc.CallOption) (*GetMapRouterResp, error) {
	out := new(GetMapRouterResp)
	err := c.cc.Invoke(ctx, "/storesvr.StoreServer/GetMapRouter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeServerClient) SetHostRouter(ctx context.Context, in *SetHostRouterReq, opts ...grpc.CallOption) (*GetMapRouterResp, error) {
	out := new(GetMapRouterResp)
	err := c.cc.Invoke(ctx, "/storesvr.StoreServer/SetHostRouter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoreServerServer is the server API for StoreServer service.
type StoreServerServer interface {
	// 更新MaxSeq
	UpdateMaxSeq(context.Context, *UpdateMaxSeqReq) (*NoContent, error)
	// 获取MaxSeq
	GetSeqMax(context.Context, *GetSeqMaxReq) (*GetSeqMaxResp, error)
	// 获取全路由表
	GetMapRouter(context.Context, *GetMapRouterReq) (*GetMapRouterResp, error)
	// 设置host路由表
	SetHostRouter(context.Context, *SetHostRouterReq) (*GetMapRouterResp, error)
}

// UnimplementedStoreServerServer can be embedded to have forward compatible implementations.
type UnimplementedStoreServerServer struct {
}

func (*UnimplementedStoreServerServer) UpdateMaxSeq(ctx context.Context, req *UpdateMaxSeqReq) (*NoContent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMaxSeq not implemented")
}
func (*UnimplementedStoreServerServer) GetSeqMax(ctx context.Context, req *GetSeqMaxReq) (*GetSeqMaxResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeqMax not implemented")
}
func (*UnimplementedStoreServerServer) GetMapRouter(ctx context.Context, req *GetMapRouterReq) (*GetMapRouterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapRouter not implemented")
}
func (*UnimplementedStoreServerServer) SetHostRouter(ctx context.Context, req *SetHostRouterReq) (*GetMapRouterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHostRouter not implemented")
}

func RegisterStoreServerServer(s *grpc.Server, srv StoreServerServer) {
	s.RegisterService(&_StoreServer_serviceDesc, srv)
}

func _StoreServer_UpdateMaxSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMaxSeqReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServerServer).UpdateMaxSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storesvr.StoreServer/UpdateMaxSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServerServer).UpdateMaxSeq(ctx, req.(*UpdateMaxSeqReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreServer_GetSeqMax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeqMaxReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServerServer).GetSeqMax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storesvr.StoreServer/GetSeqMax",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServerServer).GetSeqMax(ctx, req.(*GetSeqMaxReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreServer_GetMapRouter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapRouterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServerServer).GetMapRouter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storesvr.StoreServer/GetMapRouter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServerServer).GetMapRouter(ctx, req.(*GetMapRouterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoreServer_SetHostRouter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHostRouterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServerServer).SetHostRouter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storesvr.StoreServer/SetHostRouter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServerServer).SetHostRouter(ctx, req.(*SetHostRouterReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _StoreServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storesvr.StoreServer",
	HandlerType: (*StoreServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateMaxSeq",
			Handler:    _StoreServer_UpdateMaxSeq_Handler,
		},
		{
			MethodName: "GetSeqMax",
			Handler:    _StoreServer_GetSeqMax_Handler,
		},
		{
			MethodName: "GetMapRouter",
			Handler:    _StoreServer_GetMapRouter_Handler,
		},
		{
			MethodName: "SetHostRouter",
			Handler:    _StoreServer_SetHostRouter_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "store_server.proto",
}
